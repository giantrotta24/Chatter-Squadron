{"version":3,"sources":["../../../src/bootstrap/load-themes/index.js"],"names":["path","require","mergeGatsbyConfig","Promise","_","debug","preferDefault","getConfigFile","resolveTheme","themeSpec","themeName","resolve","themeDir","dirname","theme","themeConfig","isFunction","options","processTheme","__experimentalThemes","mapSeries","spec","themeObj","then","arr","concat","module","exports","config","themesA","flattenDeep","plugins","reduce","newConfig","themes"],"mappings":"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","sourcesContent":["const path = require(`path`)\nconst mergeGatsbyConfig = require(`../../utils/merge-gatsby-config`)\nconst Promise = require(`bluebird`)\nconst _ = require(`lodash`)\nconst debug = require(`debug`)(`gatsby:load-themes`)\nconst preferDefault = require(`../prefer-default`)\nconst getConfigFile = require(`../get-config-file`)\n\n// get the gatsby-config file for a theme\nconst resolveTheme = async themeSpec => {\n  const themeName = themeSpec.resolve || themeSpec\n  const themeDir = path.dirname(require.resolve(themeName))\n  const theme = await preferDefault(getConfigFile(themeDir, `gatsby-config`))\n  // if theme is a function, call it with the themeConfig\n  let themeConfig = theme\n  if (_.isFunction(theme)) {\n    themeConfig = theme(themeSpec.options || {})\n  }\n  return { themeName, themeConfig, themeSpec, themeDir }\n}\n\n// single iteration of a recursive function that resolve parent themes\n// It's recursive because we support child themes declaring parents and\n// have to resolve all the way `up the tree` of parent/children relationships\n//\n// Theoretically, there could be an infinite loop here but in practice there is\n// no use case for a loop so I expect that to only happen if someone is very\n// off track and creating their own set of themes\nconst processTheme = ({ themeName, themeConfig, themeSpec, themeDir }) => {\n  // gatsby themes don't have to specify a gatsby-config.js (they might only use gatsby-node, etc)\n  // in this case they're technically plugins, but we should support it anyway\n  // because we can't guarentee which files theme creators create first\n  if (themeConfig && themeConfig.__experimentalThemes) {\n    // for every parent theme a theme defines, resolve the parent's\n    // gatsby config and return it in order [parentA, parentB, child]\n    return Promise.mapSeries(themeConfig.__experimentalThemes, async spec => {\n      const themeObj = await resolveTheme(spec)\n      return processTheme(themeObj)\n    }).then(arr =>\n      arr.concat([{ themeName, themeConfig, themeSpec, themeDir }])\n    )\n  } else {\n    // if a theme doesn't define additional themes, return the original theme\n    return [{ themeName, themeConfig, themeSpec, themeDir }]\n  }\n}\n\nmodule.exports = async config => {\n  const themesA = await Promise.mapSeries(\n    config.__experimentalThemes,\n    async themeSpec => {\n      const themeObj = await resolveTheme(themeSpec)\n      return processTheme(themeObj)\n    }\n  ).then(arr => _.flattenDeep(arr))\n\n  // log out flattened themes list to aid in debugging\n  debug(themesA)\n\n  // map over each theme, adding the theme itself to the plugins\n  // list in the config for the theme. This enables the usage of\n  // gatsby-node, etc in themes.\n  return (\n    Promise.mapSeries(themesA, ({ themeName, themeConfig = {}, themeSpec }) => {\n      return {\n        ...themeConfig,\n        plugins: [\n          ...(themeConfig.plugins || []),\n          // theme plugin is last so it's gatsby-node, etc can override it's declared plugins, like a normal site.\n          { resolve: themeName, options: themeSpec.options || {} },\n        ],\n      }\n    })\n      /**\n       * themes resolve to a gatsby-config, so here we merge all of the configs\n       * into a single config, making sure to maintain the order in which\n       * they were defined so that later configs, like the user's site and\n       * children, can override functionality in earlier themes.\n       */\n      .reduce(mergeGatsbyConfig, {})\n      .then(newConfig => {\n        return {\n          config: mergeGatsbyConfig(newConfig, config),\n          themes: themesA,\n        }\n      })\n  )\n}\n"],"file":"index.js"}